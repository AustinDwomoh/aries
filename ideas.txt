now add a system that operates this way
1 when clan tournamnets are made  the creators can set wheter the change in players is dynamic or fixed from the beginning
Dynamic means clans can change players any time and fixed means they have to use stick to those players all through out
allow the tournamnets to chnage between dynamic and fixed for half season changes

create a veiw for the clans to assign users to tournamnets
and on club veiws display their stats as tables even when they are taking out\

make the clubs login and act like users and 
put some thing to you know track whter someone can be an organizer i dont want to make a model for organizers

This is a cool system you're building! Here's how I'd approach each part of what you asked for:

✅ 1. Add Dynamic/Fixed Player Mode to Tournaments
In ClanTournament, add a new field:

python
Copy
Edit
PLAYER_MODE_CHOICES = [('fixed', 'Fixed'), ('dynamic', 'Dynamic')]

player_mode = models.CharField(
    max_length=10,
    choices=PLAYER_MODE_CHOICES,
    default='dynamic',
    help_text="Whether clans can change players mid-tournament"
)
You can also add a method to toggle this mid-season:

python
Copy
Edit
def toggle_player_mode(self):
    """Switch player mode between fixed and dynamic."""
    self.player_mode = 'fixed' if self.player_mode == 'dynamic' else 'dynamic'
    self.save()
✅ 2. View for Clans to Assign Users to a Tournament
You’ll need a through model to track which users are assigned to a clan per tournament:

python
Copy
Edit
class ClanTournamentPlayer(models.Model):
    clan = models.ForeignKey(Clans, on_delete=models.CASCADE)
    tournament = models.ForeignKey(ClanTournament, on_delete=models.CASCADE)
    user = models.ForeignKey(User, on_delete=models.CASCADE)

    class Meta:
        unique_together = ('clan', 'tournament', 'user')
Then create a view like:

python
Copy
Edit
@login_required
def assign_user_to_tournament(request, tournament_id, clan_id):
    if request.method == "POST":
        user_id = request.POST.get('user_id')
        user = User.objects.get(pk=user_id)
        tournament = ClanTournament.objects.get(pk=tournament_id)
        clan = Clans.objects.get(pk=clan_id)

        if tournament.player_mode == 'fixed':
            # Check if mid-season update is allowed
            return HttpResponseForbidden("Player assignments are fixed for this tournament.")
        
        ClanTournamentPlayer.objects.get_or_create(user=user, clan=clan, tournament=tournament)
        return redirect('some-success-page')
✅ 3. Club View With Stats (Even If Removed)
In the view where clubs are shown, use ClanTournamentPlayer to display past participation, regardless of whether they’re still assigned:

python
Copy
Edit
stats = ClanTournamentPlayer.objects.filter(clan=my_club).select_related('tournament')
Use this to populate a table showing:

Tournament name

Games played

Wins, etc. (if you’re tracking this in the match data)

✅ 4. Clubs Log In Like Users
Easiest way: treat each club as a user (1-to-1):

Add a OneToOneField from Clans to User

Or, use groups/permissions to separate "club" users from regular users

python
Copy
Edit
class Clans(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    clan_name = models.CharField(max_length=255)
Then you can use Django's built-in auth and login for them.

✅ 5. Track Organizers Without New Model
You don’t need a model—use permissions or a boolean field on User:

python
Copy
Edit
# Option A: Boolean field
User.add_to_class('is_organizer', models.BooleanField(default=False))

# Option B: Use Django groups
from django.contrib.auth.models import Group
organizers_group = Group.objects.get_or_create(name='Organizers')
user.groups.add(organizers_group)
Then in views:

python
Copy
Edit
if request.user.is_organizer:
    # allow special access
Or with groups:

python
Copy
Edit
if request.user.groups.filter(name='Organizers').exists():
    # allow access
Want me to help scaffold this out with actual views/forms/templates too?